<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:googleplay="http://www.google.com/schemas/play-podcasts/1.0" xmlns:media="http://www.rssboard.org/media-rss" version="2.0">
  <channel>
    <title><![CDATA[原子能 聊 程式[YT+]]]></title>
    <link>http://www.youtube.com/feeds/videos.xml?channel_id=UCdyIYolHVk-vx4EK_Su6C6w</link>
    <image>
      <url>https://yt3.googleusercontent.com/EH3InAJCaGeyJBg7VfgZXvZnuV-GuLNwq3MmwpJ85XZa1IsVkIeqsDAIWNY0MDTxobk5NolFdts=s900-b50-c-k-c0x008A95A5-no-rj</url>
      <title>原子能 聊 程式[YT+]</title>
      <link>http://www.youtube.com/feeds/videos.xml?channel_id=UCdyIYolHVk-vx4EK_Su6C6w</link>
    </image>
    <language>en-us</language>
    <atom:link href="https://www.youtube.com/feeds/videos.xml?channel_id=UCdyIYolHVk-vx4EK_Su6C6w" rel="self" type="application/rss+xml"/>
    <copyright><![CDATA[原子能 聊 程式[YT+]]]></copyright>
    <itunes:author><![CDATA[原子能 聊 程式[YT+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[
      <a href="https://www.youtube.com/channel/UCdyIYolHVk-vx4EK_Su6C6w" target="_blank">https://www.youtube.com/channel/UCdyIYolHVk-vx4EK_Su6C6w</a><br />
<br />
<a href="https://www.youtube.com/feeds/videos.xml?channel_id=UCdyIYolHVk-vx4EK_Su6C6w" target="_blank">https://www.youtube.com/feeds/videos.xml?channel_id=UCdyIYolHVk-vx4EK_Su6C6w</a>
      ]]>
    </itunes:summary>
    <description>
      <![CDATA[
      <a href="https://www.youtube.com/channel/UCdyIYolHVk-vx4EK_Su6C6w" target="_blank">https://www.youtube.com/channel/UCdyIYolHVk-vx4EK_Su6C6w</a><br />
<br />
<a href="https://www.youtube.com/feeds/videos.xml?channel_id=UCdyIYolHVk-vx4EK_Su6C6w" target="_blank">https://www.youtube.com/feeds/videos.xml?channel_id=UCdyIYolHVk-vx4EK_Su6C6w</a>
      ]]>
    </description>
    <itunes:owner>
      <itunes:name><![CDATA[原子能 聊 程式[YT+]]]></itunes:name>
    </itunes:owner>
    <itunes:image href="https://yt3.googleusercontent.com/EH3InAJCaGeyJBg7VfgZXvZnuV-GuLNwq3MmwpJ85XZa1IsVkIeqsDAIWNY0MDTxobk5NolFdts=s900-b50-c-k-c0x008A95A5-no-rj"/>
<item>
      <title><![CDATA[这是一本每个程序员都应该读的名人传记【让阅读再次伟大#2】]]></title>
      <link>https://www.youtube.com/watch?v=qEyT3c1vMpI</link>
      <itunes:title><![CDATA[这是一本每个程序员都应该读的名人传记【让阅读再次伟大#2】]]></itunes:title>
      <itunes:author><![CDATA[原子能]]></itunes:author>
      <itunes:summary>
        <![CDATA[<hr style="clear:both" />

<p><img src="https://img.youtube.com/vi/qEyT3c1vMpI/maxresdefault.jpg" /></p><p><a href="https://www.youtube.com/watch?v=qEyT3c1vMpI">https://www.youtube.com/watch?v=qEyT3c1vMpI</a></p><h1>值得閱讀的理由</h1><ul><li>這本自傳的敘事風格與眾不同，樸實且貼近現實，能讓讀者產生共鳴，提供療癒感而非壓力。</li><li>它填補了關於 Linus Torvalds 在網際網路時代成名之前那段鮮為人知、卻至關重要的歷史空白。</li><li>書中蘊含了 Linus 對軟體開發、開源精神及商業看法的珍貴見解，這些觀點至今仍具深遠影響力。</li><li>透過本書，讀者得以了解這位傳奇人物的真實面貌，體會到他最終也是一位擁有平凡特質的人。</li></ul><hr /><h1>摘要</h1><h2>關於「有毒的傳記」</h2><p><strong>作者</strong>首先分享了他通常不建議閱讀名人傳記的理由，認為這類書籍容易影響讀者心態。尤其是看到那些似乎"開外掛"般的成功事蹟，會讓人感到遙不可及，難以產生共鳴，甚至帶來負面作用。<strong>作者</strong>坦承自己就是受害者，年輕時熟讀<strong>比爾蓋茲</strong>、<strong>賈伯斯</strong>等人的傳記，對比自己當時連基本程式都寫不出來的狀況，深感焦慮與自我懷疑，因為書中人物在同樣年紀時已經取得了巨大成就。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_78.jpg" /></p><h2>一本與眾不同的自傳</h2><p>然而，這次<strong>作者</strong>推薦的這本，恰好就是一本名人傳記——由程式設計金字塔最頂端的人物，<strong>Linus Torvalds</strong>所寫的唯一自傳。<strong>作者</strong>認為這本書很特別，它非常<strong>平易近人</strong>，能夠讓人產生強烈的共鳴，甚至稱它為<strong>「最具有療癒效果的自傳」</strong>。Linus的故事<strong>「最接地氣」</strong>，沒有富二代背景，沒有踩中風口，甚至最初沒有做出什麼<strong>天才的發明</strong>。他的成就像是無數細小的積木一點一點拼湊而成，沒有傳奇性的跌宕起伏。這本書令人產生共鳴，因為讀者能在其中看到<strong>每一個程式設計師的影子</strong>。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_143.jpg" /></p><h2><strong>Linux</strong> 的誕生：一個樸實的個人專案</h2><p><strong>作者</strong>詳細介紹了<strong>Linux</strong>系統誕生的過程，說明它如何類似於許多人折騰個人專案的經歷。一切始於Linus用零花錢買了一台貴電腦和一個貴作業系統(Minix)。由於這個系統不夠完善，尤其無法遠端登錄，作為一個宅男，Linus決定<strong>自己動手寫一個終端程式(terminal)</strong>，以便在家裡直接連上學校主機。為了實現這個目標，他有了動力去深入理解BIOS、CPU的工作原理，學習從鍵盤讀取輸入、向螢幕輸出、以及通過Modem讀寫網路數據。在這個過程中，他逐步建立起多執行緒機制。最初，這個terminal實在太好用了，導致Linus天天在家上網。於是，他自然而然地開始想要更多功能，比如檔案下載和上傳，這就需要硬碟和檔案系統的驅動。隨著寫的組件越來越多，Linus發現自己差不多是在寫一個作業系統了，於是索性將其寫成一個完整的系統，也當作是一種<strong>練習</strong>。<strong>Linux系統</strong>就這樣<strong>「正式誕生」</strong>了。<strong>作者</strong>強調，這種從個人興趣出發，邊學邊做，逐步迭代添加功能的過程，與<strong>很多程式設計師的經驗</strong>是相符的。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_9.jpg" /></p><h2>填補歷史的空白與永恆的觀點</h2><p><strong>作者</strong>指出，雖然Linus在<strong>網際網路時代</strong>出現後的事蹟廣為人知，但<strong>這之前的歷史</strong>卻鮮為人知。而這本2001年寫成的自傳，正好<strong>「填補了這部分缺失的歷史」</strong>。它是當時的Linus對自己人生、思想和觀念的全面回顧與總結，可以說是電腦行業裡一份<strong>「非常寶貴的歷史文件」</strong>。書中，Linus談到了對<strong>軟體開發</strong>的觀點、對<strong>開源</strong>的態度、以及對<strong>賺錢</strong>的看法。這些思想也奠定了Linux專案成為世界上最重要、最成功的軟體專案的基礎。<strong>作者</strong>特別強調，這些觀點在過去的二十多年裡幾乎沒有改變，<strong>「依舊非常有說服力」</strong>，這也是他更喜歡讀那些經受時間考驗的<strong>「老書」</strong>的原因之一。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_28.jpg" /></p><h2>從聖人光環到普通人的理解</h2><p>最後，<strong>作者</strong>回顧了自己曾在其他影片中將Linus比作<strong>「聖人」</strong>，因為他在<strong>「開源專案商業化」</strong>方面是唯一的破局者。然而，他認為「聖人」這個稱謂是從外部視角套上的光環，某種程度上也表現出我們對他不夠熟悉或不理解。這本自傳則在某種程度上<strong>「回答了這個問題」</strong>。透過Linus親口敘述那些平平無奇的生活細節和人生故事，我們得以慢慢認識這個人，理解他的<strong>思維</strong>、想法和慾望。最終意識到，他其實就是一個<strong>「普通人」</strong>或<strong>「平凡人」</strong>。他只是個稍微<strong>「高尚」</strong>一點、稍微<strong>「純粹」</strong>一點、稍微<strong>「有道德」</strong>一點、稍微超脫低級趣味、以及稍微願意<strong>「造福人類」</strong>的人。<strong>作者</strong>總結道，或許<strong>「聖人」</strong>和<strong>「平凡人」</strong>之間，就只有這麼一點點區別而已。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_58.jpg" /></p><hr />

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=qEyT3c1vMpI">https://www.youtube.com/watch?v=qEyT3c1vMpI</a></p><p>00:00 有毒的传记</p><p>01:24 朴素的故事</p><p>04:47 缺失的历史</p><p>06:46 圣人亦凡人</p>]]>
      </itunes:summary>
      <description>
        <![CDATA[<hr style="clear:both" />

<p><img src="https://img.youtube.com/vi/qEyT3c1vMpI/maxresdefault.jpg" /></p><p><a href="https://www.youtube.com/watch?v=qEyT3c1vMpI">https://www.youtube.com/watch?v=qEyT3c1vMpI</a></p><h1>值得閱讀的理由</h1><ul><li>這本自傳的敘事風格與眾不同，樸實且貼近現實，能讓讀者產生共鳴，提供療癒感而非壓力。</li><li>它填補了關於 Linus Torvalds 在網際網路時代成名之前那段鮮為人知、卻至關重要的歷史空白。</li><li>書中蘊含了 Linus 對軟體開發、開源精神及商業看法的珍貴見解，這些觀點至今仍具深遠影響力。</li><li>透過本書，讀者得以了解這位傳奇人物的真實面貌，體會到他最終也是一位擁有平凡特質的人。</li></ul><hr /><h1>摘要</h1><h2>關於「有毒的傳記」</h2><p><strong>作者</strong>首先分享了他通常不建議閱讀名人傳記的理由，認為這類書籍容易影響讀者心態。尤其是看到那些似乎"開外掛"般的成功事蹟，會讓人感到遙不可及，難以產生共鳴，甚至帶來負面作用。<strong>作者</strong>坦承自己就是受害者，年輕時熟讀<strong>比爾蓋茲</strong>、<strong>賈伯斯</strong>等人的傳記，對比自己當時連基本程式都寫不出來的狀況，深感焦慮與自我懷疑，因為書中人物在同樣年紀時已經取得了巨大成就。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_78.jpg" /></p><h2>一本與眾不同的自傳</h2><p>然而，這次<strong>作者</strong>推薦的這本，恰好就是一本名人傳記——由程式設計金字塔最頂端的人物，<strong>Linus Torvalds</strong>所寫的唯一自傳。<strong>作者</strong>認為這本書很特別，它非常<strong>平易近人</strong>，能夠讓人產生強烈的共鳴，甚至稱它為<strong>「最具有療癒效果的自傳」</strong>。Linus的故事<strong>「最接地氣」</strong>，沒有富二代背景，沒有踩中風口，甚至最初沒有做出什麼<strong>天才的發明</strong>。他的成就像是無數細小的積木一點一點拼湊而成，沒有傳奇性的跌宕起伏。這本書令人產生共鳴，因為讀者能在其中看到<strong>每一個程式設計師的影子</strong>。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_143.jpg" /></p><h2><strong>Linux</strong> 的誕生：一個樸實的個人專案</h2><p><strong>作者</strong>詳細介紹了<strong>Linux</strong>系統誕生的過程，說明它如何類似於許多人折騰個人專案的經歷。一切始於Linus用零花錢買了一台貴電腦和一個貴作業系統(Minix)。由於這個系統不夠完善，尤其無法遠端登錄，作為一個宅男，Linus決定<strong>自己動手寫一個終端程式(terminal)</strong>，以便在家裡直接連上學校主機。為了實現這個目標，他有了動力去深入理解BIOS、CPU的工作原理，學習從鍵盤讀取輸入、向螢幕輸出、以及通過Modem讀寫網路數據。在這個過程中，他逐步建立起多執行緒機制。最初，這個terminal實在太好用了，導致Linus天天在家上網。於是，他自然而然地開始想要更多功能，比如檔案下載和上傳，這就需要硬碟和檔案系統的驅動。隨著寫的組件越來越多，Linus發現自己差不多是在寫一個作業系統了，於是索性將其寫成一個完整的系統，也當作是一種<strong>練習</strong>。<strong>Linux系統</strong>就這樣<strong>「正式誕生」</strong>了。<strong>作者</strong>強調，這種從個人興趣出發，邊學邊做，逐步迭代添加功能的過程，與<strong>很多程式設計師的經驗</strong>是相符的。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_9.jpg" /></p><h2>填補歷史的空白與永恆的觀點</h2><p><strong>作者</strong>指出，雖然Linus在<strong>網際網路時代</strong>出現後的事蹟廣為人知，但<strong>這之前的歷史</strong>卻鮮為人知。而這本2001年寫成的自傳，正好<strong>「填補了這部分缺失的歷史」</strong>。它是當時的Linus對自己人生、思想和觀念的全面回顧與總結，可以說是電腦行業裡一份<strong>「非常寶貴的歷史文件」</strong>。書中，Linus談到了對<strong>軟體開發</strong>的觀點、對<strong>開源</strong>的態度、以及對<strong>賺錢</strong>的看法。這些思想也奠定了Linux專案成為世界上最重要、最成功的軟體專案的基礎。<strong>作者</strong>特別強調，這些觀點在過去的二十多年裡幾乎沒有改變，<strong>「依舊非常有說服力」</strong>，這也是他更喜歡讀那些經受時間考驗的<strong>「老書」</strong>的原因之一。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_28.jpg" /></p><h2>從聖人光環到普通人的理解</h2><p>最後，<strong>作者</strong>回顧了自己曾在其他影片中將Linus比作<strong>「聖人」</strong>，因為他在<strong>「開源專案商業化」</strong>方面是唯一的破局者。然而，他認為「聖人」這個稱謂是從外部視角套上的光環，某種程度上也表現出我們對他不夠熟悉或不理解。這本自傳則在某種程度上<strong>「回答了這個問題」</strong>。透過Linus親口敘述那些平平無奇的生活細節和人生故事，我們得以慢慢認識這個人，理解他的<strong>思維</strong>、想法和慾望。最終意識到，他其實就是一個<strong>「普通人」</strong>或<strong>「平凡人」</strong>。他只是個稍微<strong>「高尚」</strong>一點、稍微<strong>「純粹」</strong>一點、稍微<strong>「有道德」</strong>一點、稍微超脫低級趣味、以及稍微願意<strong>「造福人類」</strong>的人。<strong>作者</strong>總結道，或許<strong>「聖人」</strong>和<strong>「平凡人」</strong>之間，就只有這麼一點點區別而已。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_58.jpg" /></p><hr />

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=qEyT3c1vMpI">https://www.youtube.com/watch?v=qEyT3c1vMpI</a></p><p>00:00 有毒的传记</p><p>01:24 朴素的故事</p><p>04:47 缺失的历史</p><p>06:46 圣人亦凡人</p>]]>
      </description>
      <content:encoded><![CDATA[<hr style="clear:both" />

<p><img src="https://img.youtube.com/vi/qEyT3c1vMpI/maxresdefault.jpg" /></p><p><a href="https://www.youtube.com/watch?v=qEyT3c1vMpI">https://www.youtube.com/watch?v=qEyT3c1vMpI</a></p><h1>值得閱讀的理由</h1><ul><li>這本自傳的敘事風格與眾不同，樸實且貼近現實，能讓讀者產生共鳴，提供療癒感而非壓力。</li><li>它填補了關於 Linus Torvalds 在網際網路時代成名之前那段鮮為人知、卻至關重要的歷史空白。</li><li>書中蘊含了 Linus 對軟體開發、開源精神及商業看法的珍貴見解，這些觀點至今仍具深遠影響力。</li><li>透過本書，讀者得以了解這位傳奇人物的真實面貌，體會到他最終也是一位擁有平凡特質的人。</li></ul><hr /><h1>摘要</h1><h2>關於「有毒的傳記」</h2><p><strong>作者</strong>首先分享了他通常不建議閱讀名人傳記的理由，認為這類書籍容易影響讀者心態。尤其是看到那些似乎"開外掛"般的成功事蹟，會讓人感到遙不可及，難以產生共鳴，甚至帶來負面作用。<strong>作者</strong>坦承自己就是受害者，年輕時熟讀<strong>比爾蓋茲</strong>、<strong>賈伯斯</strong>等人的傳記，對比自己當時連基本程式都寫不出來的狀況，深感焦慮與自我懷疑，因為書中人物在同樣年紀時已經取得了巨大成就。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_78.jpg" /></p><h2>一本與眾不同的自傳</h2><p>然而，這次<strong>作者</strong>推薦的這本，恰好就是一本名人傳記——由程式設計金字塔最頂端的人物，<strong>Linus Torvalds</strong>所寫的唯一自傳。<strong>作者</strong>認為這本書很特別，它非常<strong>平易近人</strong>，能夠讓人產生強烈的共鳴，甚至稱它為<strong>「最具有療癒效果的自傳」</strong>。Linus的故事<strong>「最接地氣」</strong>，沒有富二代背景，沒有踩中風口，甚至最初沒有做出什麼<strong>天才的發明</strong>。他的成就像是無數細小的積木一點一點拼湊而成，沒有傳奇性的跌宕起伏。這本書令人產生共鳴，因為讀者能在其中看到<strong>每一個程式設計師的影子</strong>。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_143.jpg" /></p><h2><strong>Linux</strong> 的誕生：一個樸實的個人專案</h2><p><strong>作者</strong>詳細介紹了<strong>Linux</strong>系統誕生的過程，說明它如何類似於許多人折騰個人專案的經歷。一切始於Linus用零花錢買了一台貴電腦和一個貴作業系統(Minix)。由於這個系統不夠完善，尤其無法遠端登錄，作為一個宅男，Linus決定<strong>自己動手寫一個終端程式(terminal)</strong>，以便在家裡直接連上學校主機。為了實現這個目標，他有了動力去深入理解BIOS、CPU的工作原理，學習從鍵盤讀取輸入、向螢幕輸出、以及通過Modem讀寫網路數據。在這個過程中，他逐步建立起多執行緒機制。最初，這個terminal實在太好用了，導致Linus天天在家上網。於是，他自然而然地開始想要更多功能，比如檔案下載和上傳，這就需要硬碟和檔案系統的驅動。隨著寫的組件越來越多，Linus發現自己差不多是在寫一個作業系統了，於是索性將其寫成一個完整的系統，也當作是一種<strong>練習</strong>。<strong>Linux系統</strong>就這樣<strong>「正式誕生」</strong>了。<strong>作者</strong>強調，這種從個人興趣出發，邊學邊做，逐步迭代添加功能的過程，與<strong>很多程式設計師的經驗</strong>是相符的。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_9.jpg" /></p><h2>填補歷史的空白與永恆的觀點</h2><p><strong>作者</strong>指出，雖然Linus在<strong>網際網路時代</strong>出現後的事蹟廣為人知，但<strong>這之前的歷史</strong>卻鮮為人知。而這本2001年寫成的自傳，正好<strong>「填補了這部分缺失的歷史」</strong>。它是當時的Linus對自己人生、思想和觀念的全面回顧與總結，可以說是電腦行業裡一份<strong>「非常寶貴的歷史文件」</strong>。書中，Linus談到了對<strong>軟體開發</strong>的觀點、對<strong>開源</strong>的態度、以及對<strong>賺錢</strong>的看法。這些思想也奠定了Linux專案成為世界上最重要、最成功的軟體專案的基礎。<strong>作者</strong>特別強調，這些觀點在過去的二十多年裡幾乎沒有改變，<strong>「依舊非常有說服力」</strong>，這也是他更喜歡讀那些經受時間考驗的<strong>「老書」</strong>的原因之一。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_28.jpg" /></p><h2>從聖人光環到普通人的理解</h2><p>最後，<strong>作者</strong>回顧了自己曾在其他影片中將Linus比作<strong>「聖人」</strong>，因為他在<strong>「開源專案商業化」</strong>方面是唯一的破局者。然而，他認為「聖人」這個稱謂是從外部視角套上的光環，某種程度上也表現出我們對他不夠熟悉或不理解。這本自傳則在某種程度上<strong>「回答了這個問題」</strong>。透過Linus親口敘述那些平平無奇的生活細節和人生故事，我們得以慢慢認識這個人，理解他的<strong>思維</strong>、想法和慾望。最終意識到，他其實就是一個<strong>「普通人」</strong>或<strong>「平凡人」</strong>。他只是個稍微<strong>「高尚」</strong>一點、稍微<strong>「純粹」</strong>一點、稍微<strong>「有道德」</strong>一點、稍微超脫低級趣味、以及稍微願意<strong>「造福人類」</strong>的人。<strong>作者</strong>總結道，或許<strong>「聖人」</strong>和<strong>「平凡人」</strong>之間，就只有這麼一點點區別而已。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/qEyT3c1vMpI_58.jpg" /></p><hr />

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=qEyT3c1vMpI">https://www.youtube.com/watch?v=qEyT3c1vMpI</a></p><p>00:00 有毒的传记</p><p>01:24 朴素的故事</p><p>04:47 缺失的历史</p><p>06:46 圣人亦凡人</p>]]></content:encoded>
      <itunes:image href="https://i.ytimg.com/vi/qEyT3c1vMpI/hqdefault.jpg"/>
      <pubDate>2025-07-07T10:03:59.000Z</pubDate>
    </item><item>
      <title><![CDATA[有些数据库是蠢，有些是坏，它是又蠢又坏【让编程再次伟大#番外2】]]></title>
      <link>https://www.youtube.com/watch?v=ConMAwL-cmk</link>
      <itunes:title><![CDATA[有些数据库是蠢，有些是坏，它是又蠢又坏【让编程再次伟大#番外2】]]></itunes:title>
      <itunes:author><![CDATA[原子能]]></itunes:author>
      <itunes:summary>
        <![CDATA[<hr style="clear:both" />

<p><img src="https://img.youtube.com/vi/ConMAwL-cmk/maxresdefault.jpg" /></p><h1>值得閱讀的理由</h1><ul><li>了解為何許多開發者認為進階的資料庫功能（如 Foreign Key 和 Transaction）在 MySQL 中不可靠或應避免使用。</li><li>透過具體範例深入探討 MySQL 在處理 Foreign Key 與 Index 的怪異互動，以及其 Transaction 對 DDL 命令的支援缺陷。</li><li>理解作者為何對 MySQL 的基本設計進行猛烈批評，及其對程式設計師資料庫知識學習的負面影響。</li></ul><hr /><h1>摘要</h1><h2>開場與炮轟的真正意義</h2><p>作者提到先前發布了批評 MySQL 的影片，引起熱烈反響，但其中許多是針對作者的謾罵。許多觀眾認為作者列舉的 MySQL 錯誤都是「沒人用」的邊角料，並表示「懂行的人」都知道不應該使用 Composite Index、Foreign Key、Enum、Trigger 等功能。作者起初以為觀眾在玩梗，甚至開玩笑地建議直接使用 Excel，結果遭到更多批評。這讓作者意識到，原來許多人是真心這麼想的，並且這種想法非常普遍。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_95.jpg" /></p><p>作者從驚訝轉為同情，認為這種現象源於 MySQL 的先發優勢和普及度，許多人從職業生涯開始接觸到的資料庫都是 MySQL，且由於其固有的缺陷，許多基本功能（除了 <strong>CRUD</strong>）都充滿錯誤且無法正常使用。這導致開發者在日常工作中被各種文件、規範和前輩的經驗灌輸，潛移默化地形成一種「閉環的常識」，認為資料庫不過是個電子表格，因此「懂行的人」只會使用 <strong>CRUD</strong>。作者因此更深刻地意識到批評 MySQL 的必要性，不僅是因為其技術缺陷，更是因為它的根深蒂固污染了一代又一代程式設計師對資料庫的認知，讓他們誤以為資料庫是個簡陋原始的工具，進而輕視這項技術。作者也終於明白，為何有人質疑他聲稱用資料庫實現全部系統邏輯的真實性，因為在他們想像中的 MySQL 裡，這是不可能的任務。因此，讓更多人認識到 MySQL 有多差勁，成了作者的使命。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_120.jpg" /></p><hr /><h2>真假 Foreign Key</h2><p>本次批評主要針對 MySQL 的設計缺陷，導致它連最基本的資料庫原理都無法遵守。以大家熟悉的 <strong>Foreign Key (FK)</strong> 原理為例，它不僅是用來讓使用者知道表格之間的關聯，更重要的是讓資料庫知道在資料改動時要維護這種關聯不被影響，例如確保 <strong>referential integrity</strong> (引用完整性)。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_166.jpg" /></p><p>作者透過一個例子說明，在標準資料庫中，如果修改一個訂單的買家，使用 `ON UPDATE CASCADE` 時，系統會暫時鎖定買家表格中對應的新買家資料，以保證資料的完整性。然而，在 MySQL 中，卻出現一個詭異的現象：即使只修改訂單的「狀態」（這與買家表格或 Foreign Key 毫無關聯，只屬於訂單表格的欄位），買家表格還是會被鎖住。這個現象通常只會在 Foreign Key 相關的操作中發生。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_206.jpg" /></p><p>原因在於訂單表格裡的一個 <strong>Index</strong>。因為訂單狀態和買家 ID 出現在同一個 Index 裡，MySQL 莫名其妙地就把訂單狀態也當作是 Foreign Key 一樣管制了。沒有人能理解這個設計背後的邏輯。有人將此作為 bug 提交，但 MySQL 官方認為這不是 bug，而是一個 feature (功能)。對於這個問題本身，他們給的建議是直接把這個 Index 刪掉。聰明的網友還發現了另一個解決方案：在訂單表格裡再加一個 <strong>Index</strong>，一個「只有買家 ID」的 Index。這樣 MySQL 就會神奇地放過訂單狀態，更新它也不會再鎖住買家表格。這個現象的原理同樣難以理解，但對於看過作者上一期批評影片的觀眾來說，應該對 MySQL 那些讓人措手不及的 <strong>Index</strong> 副作用見怪不怪了。這一次更是將 <strong>Foreign Key</strong> 和 <strong>Index</strong> 這兩個看似不相關的概念混在一起。作者感嘆普通人真的跟不上 MySQL 團隊的思路。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_274.jpg" /></p><hr /><h2>這裡是 Transaction 該滾的是你吧</h2><p>接下來探討更離譜的問題。 <strong>Transaction</strong> 是現代資料庫系統中最核心的功能之一。它將多個命令打包，要嘛全部成功，要嘛中間失敗就全部回滾（符合 <strong>ACID</strong> 原理）。可以說是 <strong>ACID</strong> 原理最完美的體現。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_297.jpg" /></p><p>然而，MySQL 的 <strong>Transaction</strong> 是殘缺的。標準 SQL 中有不同類型的命令，最常見的是定義資料結構的 <strong>DDL</strong> (如 CREATE TABLE, DROP TABLE) 和操作資料的 <strong>DML</strong> (如 INSERT, SELECT, UPDATE, DELETE)。在眾多命令類型中，MySQL 的 <strong>Transaction</strong> 卻只能管得住 <strong>DML</strong> 命令。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_329.jpg" /></p><p>作者舉例說明一個包含三個步驟的 Transaction：先將資料從舊表格複製到新表格 (DML)，然後刪除舊表格 (DDL)，最後將此操作記錄到稽核表格 (DML)。總共三行命令。但如果因為巧合，最後寫入稽核表格時出錯，導致整個 Transaction 失敗需要回滾，麻煩就大了。因為在 MySQL 中，第二行的 <strong>DROP TABLE</strong> 是 <strong>DDL</strong> 命令，它凌駕於 Transaction 之上，即使寫在 Transaction 內部，其執行也是獨立於 Transaction 之外的。用人話來說，就是當 Transaction 需要回滾時，它沒有辦法要求這行 <strong>DDL</strong> 命令也回滾。所以這個例子中，只有第一和第三行 <strong>DML</strong> 命令會被回滾。現在的狀況就變成了：舊資料表格已經被徹底 <strong>DROP</strong> 掉無法恢復，新資料表格因為被回滾了所以是空的，連稽核表格也沒有留下此次操作的任何記錄。唯一的選擇就是跟領導解釋，這都是 MySQL 的錯，你並不是在刪庫跑路。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_398.jpg" /></p><hr /><h2>標準？什麼標準？</h2><p>從以上兩個案例可以看出，MySQL 在設計上根本沒有把 <strong>SQL 標準</strong> 放在眼裡。平心而論，也沒有哪個資料庫能百分之百還原 <strong>SQL 標準</strong>。有些為了打造自身優勢會加入很多自訂功能；有些是因為標準更新太快，未能及時發布新功能。但對於那些經久不衰的基本功能、基本標準、基本原理，絕大部分資料庫都是非常尊重的。只要你認真學了資料庫入門知識，你的知識基本上都是通用的。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_435.jpg" /></p><p>唯獨 MySQL 要搞特殊，連基本原理都不遵守，導致很多年輕人學到的資料庫知識是「學完就廢」。它甚至都沒有歷史遺留問題的藉口，因為 MySQL 的開發在 1994 年才開始，是主流資料庫裡最晚的那個。當時的 <strong>SQL 標準</strong> 已經非常成熟了，該有的基本都有了。但 MySQL 就連對著標準答案照抄都不願意做，反而自己搗鼓出一堆無法自圓其說的爛尾問題，導致一代又一代的程式設計師被帶歪、誤入歧途。所以在最後，作者只能提出一個問題：你說 MySQL 這是蠢呢？還是壞呢？</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_481.jpg" /></p><hr />

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=ConMAwL-cmk">https://www.youtube.com/watch?v=ConMAwL-cmk</a></p><p>00:00 开场</p><p>00:43 炮轰的真正意义</p><p>02:01 真假foreign key</p><p>04:35 这里是transaction该滚的是你吧</p><p>06:39 标准？什么标准？</p>]]>
      </itunes:summary>
      <description>
        <![CDATA[<hr style="clear:both" />

<p><img src="https://img.youtube.com/vi/ConMAwL-cmk/maxresdefault.jpg" /></p><h1>值得閱讀的理由</h1><ul><li>了解為何許多開發者認為進階的資料庫功能（如 Foreign Key 和 Transaction）在 MySQL 中不可靠或應避免使用。</li><li>透過具體範例深入探討 MySQL 在處理 Foreign Key 與 Index 的怪異互動，以及其 Transaction 對 DDL 命令的支援缺陷。</li><li>理解作者為何對 MySQL 的基本設計進行猛烈批評，及其對程式設計師資料庫知識學習的負面影響。</li></ul><hr /><h1>摘要</h1><h2>開場與炮轟的真正意義</h2><p>作者提到先前發布了批評 MySQL 的影片，引起熱烈反響，但其中許多是針對作者的謾罵。許多觀眾認為作者列舉的 MySQL 錯誤都是「沒人用」的邊角料，並表示「懂行的人」都知道不應該使用 Composite Index、Foreign Key、Enum、Trigger 等功能。作者起初以為觀眾在玩梗，甚至開玩笑地建議直接使用 Excel，結果遭到更多批評。這讓作者意識到，原來許多人是真心這麼想的，並且這種想法非常普遍。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_95.jpg" /></p><p>作者從驚訝轉為同情，認為這種現象源於 MySQL 的先發優勢和普及度，許多人從職業生涯開始接觸到的資料庫都是 MySQL，且由於其固有的缺陷，許多基本功能（除了 <strong>CRUD</strong>）都充滿錯誤且無法正常使用。這導致開發者在日常工作中被各種文件、規範和前輩的經驗灌輸，潛移默化地形成一種「閉環的常識」，認為資料庫不過是個電子表格，因此「懂行的人」只會使用 <strong>CRUD</strong>。作者因此更深刻地意識到批評 MySQL 的必要性，不僅是因為其技術缺陷，更是因為它的根深蒂固污染了一代又一代程式設計師對資料庫的認知，讓他們誤以為資料庫是個簡陋原始的工具，進而輕視這項技術。作者也終於明白，為何有人質疑他聲稱用資料庫實現全部系統邏輯的真實性，因為在他們想像中的 MySQL 裡，這是不可能的任務。因此，讓更多人認識到 MySQL 有多差勁，成了作者的使命。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_120.jpg" /></p><hr /><h2>真假 Foreign Key</h2><p>本次批評主要針對 MySQL 的設計缺陷，導致它連最基本的資料庫原理都無法遵守。以大家熟悉的 <strong>Foreign Key (FK)</strong> 原理為例，它不僅是用來讓使用者知道表格之間的關聯，更重要的是讓資料庫知道在資料改動時要維護這種關聯不被影響，例如確保 <strong>referential integrity</strong> (引用完整性)。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_166.jpg" /></p><p>作者透過一個例子說明，在標準資料庫中，如果修改一個訂單的買家，使用 `ON UPDATE CASCADE` 時，系統會暫時鎖定買家表格中對應的新買家資料，以保證資料的完整性。然而，在 MySQL 中，卻出現一個詭異的現象：即使只修改訂單的「狀態」（這與買家表格或 Foreign Key 毫無關聯，只屬於訂單表格的欄位），買家表格還是會被鎖住。這個現象通常只會在 Foreign Key 相關的操作中發生。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_206.jpg" /></p><p>原因在於訂單表格裡的一個 <strong>Index</strong>。因為訂單狀態和買家 ID 出現在同一個 Index 裡，MySQL 莫名其妙地就把訂單狀態也當作是 Foreign Key 一樣管制了。沒有人能理解這個設計背後的邏輯。有人將此作為 bug 提交，但 MySQL 官方認為這不是 bug，而是一個 feature (功能)。對於這個問題本身，他們給的建議是直接把這個 Index 刪掉。聰明的網友還發現了另一個解決方案：在訂單表格裡再加一個 <strong>Index</strong>，一個「只有買家 ID」的 Index。這樣 MySQL 就會神奇地放過訂單狀態，更新它也不會再鎖住買家表格。這個現象的原理同樣難以理解，但對於看過作者上一期批評影片的觀眾來說，應該對 MySQL 那些讓人措手不及的 <strong>Index</strong> 副作用見怪不怪了。這一次更是將 <strong>Foreign Key</strong> 和 <strong>Index</strong> 這兩個看似不相關的概念混在一起。作者感嘆普通人真的跟不上 MySQL 團隊的思路。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_274.jpg" /></p><hr /><h2>這裡是 Transaction 該滾的是你吧</h2><p>接下來探討更離譜的問題。 <strong>Transaction</strong> 是現代資料庫系統中最核心的功能之一。它將多個命令打包，要嘛全部成功，要嘛中間失敗就全部回滾（符合 <strong>ACID</strong> 原理）。可以說是 <strong>ACID</strong> 原理最完美的體現。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_297.jpg" /></p><p>然而，MySQL 的 <strong>Transaction</strong> 是殘缺的。標準 SQL 中有不同類型的命令，最常見的是定義資料結構的 <strong>DDL</strong> (如 CREATE TABLE, DROP TABLE) 和操作資料的 <strong>DML</strong> (如 INSERT, SELECT, UPDATE, DELETE)。在眾多命令類型中，MySQL 的 <strong>Transaction</strong> 卻只能管得住 <strong>DML</strong> 命令。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_329.jpg" /></p><p>作者舉例說明一個包含三個步驟的 Transaction：先將資料從舊表格複製到新表格 (DML)，然後刪除舊表格 (DDL)，最後將此操作記錄到稽核表格 (DML)。總共三行命令。但如果因為巧合，最後寫入稽核表格時出錯，導致整個 Transaction 失敗需要回滾，麻煩就大了。因為在 MySQL 中，第二行的 <strong>DROP TABLE</strong> 是 <strong>DDL</strong> 命令，它凌駕於 Transaction 之上，即使寫在 Transaction 內部，其執行也是獨立於 Transaction 之外的。用人話來說，就是當 Transaction 需要回滾時，它沒有辦法要求這行 <strong>DDL</strong> 命令也回滾。所以這個例子中，只有第一和第三行 <strong>DML</strong> 命令會被回滾。現在的狀況就變成了：舊資料表格已經被徹底 <strong>DROP</strong> 掉無法恢復，新資料表格因為被回滾了所以是空的，連稽核表格也沒有留下此次操作的任何記錄。唯一的選擇就是跟領導解釋，這都是 MySQL 的錯，你並不是在刪庫跑路。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_398.jpg" /></p><hr /><h2>標準？什麼標準？</h2><p>從以上兩個案例可以看出，MySQL 在設計上根本沒有把 <strong>SQL 標準</strong> 放在眼裡。平心而論，也沒有哪個資料庫能百分之百還原 <strong>SQL 標準</strong>。有些為了打造自身優勢會加入很多自訂功能；有些是因為標準更新太快，未能及時發布新功能。但對於那些經久不衰的基本功能、基本標準、基本原理，絕大部分資料庫都是非常尊重的。只要你認真學了資料庫入門知識，你的知識基本上都是通用的。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_435.jpg" /></p><p>唯獨 MySQL 要搞特殊，連基本原理都不遵守，導致很多年輕人學到的資料庫知識是「學完就廢」。它甚至都沒有歷史遺留問題的藉口，因為 MySQL 的開發在 1994 年才開始，是主流資料庫裡最晚的那個。當時的 <strong>SQL 標準</strong> 已經非常成熟了，該有的基本都有了。但 MySQL 就連對著標準答案照抄都不願意做，反而自己搗鼓出一堆無法自圓其說的爛尾問題，導致一代又一代的程式設計師被帶歪、誤入歧途。所以在最後，作者只能提出一個問題：你說 MySQL 這是蠢呢？還是壞呢？</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_481.jpg" /></p><hr />

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=ConMAwL-cmk">https://www.youtube.com/watch?v=ConMAwL-cmk</a></p><p>00:00 开场</p><p>00:43 炮轰的真正意义</p><p>02:01 真假foreign key</p><p>04:35 这里是transaction该滚的是你吧</p><p>06:39 标准？什么标准？</p>]]>
      </description>
      <content:encoded><![CDATA[<hr style="clear:both" />

<p><img src="https://img.youtube.com/vi/ConMAwL-cmk/maxresdefault.jpg" /></p><h1>值得閱讀的理由</h1><ul><li>了解為何許多開發者認為進階的資料庫功能（如 Foreign Key 和 Transaction）在 MySQL 中不可靠或應避免使用。</li><li>透過具體範例深入探討 MySQL 在處理 Foreign Key 與 Index 的怪異互動，以及其 Transaction 對 DDL 命令的支援缺陷。</li><li>理解作者為何對 MySQL 的基本設計進行猛烈批評，及其對程式設計師資料庫知識學習的負面影響。</li></ul><hr /><h1>摘要</h1><h2>開場與炮轟的真正意義</h2><p>作者提到先前發布了批評 MySQL 的影片，引起熱烈反響，但其中許多是針對作者的謾罵。許多觀眾認為作者列舉的 MySQL 錯誤都是「沒人用」的邊角料，並表示「懂行的人」都知道不應該使用 Composite Index、Foreign Key、Enum、Trigger 等功能。作者起初以為觀眾在玩梗，甚至開玩笑地建議直接使用 Excel，結果遭到更多批評。這讓作者意識到，原來許多人是真心這麼想的，並且這種想法非常普遍。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_95.jpg" /></p><p>作者從驚訝轉為同情，認為這種現象源於 MySQL 的先發優勢和普及度，許多人從職業生涯開始接觸到的資料庫都是 MySQL，且由於其固有的缺陷，許多基本功能（除了 <strong>CRUD</strong>）都充滿錯誤且無法正常使用。這導致開發者在日常工作中被各種文件、規範和前輩的經驗灌輸，潛移默化地形成一種「閉環的常識」，認為資料庫不過是個電子表格，因此「懂行的人」只會使用 <strong>CRUD</strong>。作者因此更深刻地意識到批評 MySQL 的必要性，不僅是因為其技術缺陷，更是因為它的根深蒂固污染了一代又一代程式設計師對資料庫的認知，讓他們誤以為資料庫是個簡陋原始的工具，進而輕視這項技術。作者也終於明白，為何有人質疑他聲稱用資料庫實現全部系統邏輯的真實性，因為在他們想像中的 MySQL 裡，這是不可能的任務。因此，讓更多人認識到 MySQL 有多差勁，成了作者的使命。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_120.jpg" /></p><hr /><h2>真假 Foreign Key</h2><p>本次批評主要針對 MySQL 的設計缺陷，導致它連最基本的資料庫原理都無法遵守。以大家熟悉的 <strong>Foreign Key (FK)</strong> 原理為例，它不僅是用來讓使用者知道表格之間的關聯，更重要的是讓資料庫知道在資料改動時要維護這種關聯不被影響，例如確保 <strong>referential integrity</strong> (引用完整性)。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_166.jpg" /></p><p>作者透過一個例子說明，在標準資料庫中，如果修改一個訂單的買家，使用 `ON UPDATE CASCADE` 時，系統會暫時鎖定買家表格中對應的新買家資料，以保證資料的完整性。然而，在 MySQL 中，卻出現一個詭異的現象：即使只修改訂單的「狀態」（這與買家表格或 Foreign Key 毫無關聯，只屬於訂單表格的欄位），買家表格還是會被鎖住。這個現象通常只會在 Foreign Key 相關的操作中發生。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_206.jpg" /></p><p>原因在於訂單表格裡的一個 <strong>Index</strong>。因為訂單狀態和買家 ID 出現在同一個 Index 裡，MySQL 莫名其妙地就把訂單狀態也當作是 Foreign Key 一樣管制了。沒有人能理解這個設計背後的邏輯。有人將此作為 bug 提交，但 MySQL 官方認為這不是 bug，而是一個 feature (功能)。對於這個問題本身，他們給的建議是直接把這個 Index 刪掉。聰明的網友還發現了另一個解決方案：在訂單表格裡再加一個 <strong>Index</strong>，一個「只有買家 ID」的 Index。這樣 MySQL 就會神奇地放過訂單狀態，更新它也不會再鎖住買家表格。這個現象的原理同樣難以理解，但對於看過作者上一期批評影片的觀眾來說，應該對 MySQL 那些讓人措手不及的 <strong>Index</strong> 副作用見怪不怪了。這一次更是將 <strong>Foreign Key</strong> 和 <strong>Index</strong> 這兩個看似不相關的概念混在一起。作者感嘆普通人真的跟不上 MySQL 團隊的思路。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_274.jpg" /></p><hr /><h2>這裡是 Transaction 該滾的是你吧</h2><p>接下來探討更離譜的問題。 <strong>Transaction</strong> 是現代資料庫系統中最核心的功能之一。它將多個命令打包，要嘛全部成功，要嘛中間失敗就全部回滾（符合 <strong>ACID</strong> 原理）。可以說是 <strong>ACID</strong> 原理最完美的體現。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_297.jpg" /></p><p>然而，MySQL 的 <strong>Transaction</strong> 是殘缺的。標準 SQL 中有不同類型的命令，最常見的是定義資料結構的 <strong>DDL</strong> (如 CREATE TABLE, DROP TABLE) 和操作資料的 <strong>DML</strong> (如 INSERT, SELECT, UPDATE, DELETE)。在眾多命令類型中，MySQL 的 <strong>Transaction</strong> 卻只能管得住 <strong>DML</strong> 命令。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_329.jpg" /></p><p>作者舉例說明一個包含三個步驟的 Transaction：先將資料從舊表格複製到新表格 (DML)，然後刪除舊表格 (DDL)，最後將此操作記錄到稽核表格 (DML)。總共三行命令。但如果因為巧合，最後寫入稽核表格時出錯，導致整個 Transaction 失敗需要回滾，麻煩就大了。因為在 MySQL 中，第二行的 <strong>DROP TABLE</strong> 是 <strong>DDL</strong> 命令，它凌駕於 Transaction 之上，即使寫在 Transaction 內部，其執行也是獨立於 Transaction 之外的。用人話來說，就是當 Transaction 需要回滾時，它沒有辦法要求這行 <strong>DDL</strong> 命令也回滾。所以這個例子中，只有第一和第三行 <strong>DML</strong> 命令會被回滾。現在的狀況就變成了：舊資料表格已經被徹底 <strong>DROP</strong> 掉無法恢復，新資料表格因為被回滾了所以是空的，連稽核表格也沒有留下此次操作的任何記錄。唯一的選擇就是跟領導解釋，這都是 MySQL 的錯，你並不是在刪庫跑路。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_398.jpg" /></p><hr /><h2>標準？什麼標準？</h2><p>從以上兩個案例可以看出，MySQL 在設計上根本沒有把 <strong>SQL 標準</strong> 放在眼裡。平心而論，也沒有哪個資料庫能百分之百還原 <strong>SQL 標準</strong>。有些為了打造自身優勢會加入很多自訂功能；有些是因為標準更新太快，未能及時發布新功能。但對於那些經久不衰的基本功能、基本標準、基本原理，絕大部分資料庫都是非常尊重的。只要你認真學了資料庫入門知識，你的知識基本上都是通用的。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_435.jpg" /></p><p>唯獨 MySQL 要搞特殊，連基本原理都不遵守，導致很多年輕人學到的資料庫知識是「學完就廢」。它甚至都沒有歷史遺留問題的藉口，因為 MySQL 的開發在 1994 年才開始，是主流資料庫裡最晚的那個。當時的 <strong>SQL 標準</strong> 已經非常成熟了，該有的基本都有了。但 MySQL 就連對著標準答案照抄都不願意做，反而自己搗鼓出一堆無法自圓其說的爛尾問題，導致一代又一代的程式設計師被帶歪、誤入歧途。所以在最後，作者只能提出一個問題：你說 MySQL 這是蠢呢？還是壞呢？</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/ConMAwL-cmk_481.jpg" /></p><hr />

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=ConMAwL-cmk">https://www.youtube.com/watch?v=ConMAwL-cmk</a></p><p>00:00 开场</p><p>00:43 炮轰的真正意义</p><p>02:01 真假foreign key</p><p>04:35 这里是transaction该滚的是你吧</p><p>06:39 标准？什么标准？</p>]]></content:encoded>
      <itunes:image href="https://i.ytimg.com/vi/ConMAwL-cmk/hqdefault.jpg"/>
      <pubDate>2025-06-26T10:25:54.000Z</pubDate>
    </item><item>
      <title><![CDATA[为什么计算机行业总是由小错误引发大灾难【让编程再次伟大#40】]]></title>
      <link>https://www.youtube.com/watch?v=eF0SFyCGWlg</link>
      <itunes:title><![CDATA[为什么计算机行业总是由小错误引发大灾难【让编程再次伟大#40】]]></itunes:title>
      <itunes:author><![CDATA[原子能]]></itunes:author>
      <itunes:summary>
        <![CDATA[<hr style="clear:both" />

<p><img src="https://img.youtube.com/vi/eF0SFyCGWlg/maxresdefault.jpg" /></p><h1>值得閱讀的理由</h1><ul><li>了解 Google Cloud 在 2025 年 6 月 12 日癱瘓的技術原因，以及一系列看似微小、但在各個階段累積的錯誤如何引發全球性災難。</li><li>探討軟體產業在開發、測試、部署及營運流程中常見的問題，特別是缺乏嚴謹的態度和對潛在風險的意識。</li><li>比較軟體產業與航空業在處理錯誤和追求安全上的差異，反思前者應如何借鏡其他高度監管產業的紀律性與責任感。</li></ul><hr /><h1>摘要</h1><p>作者指出，歷史上最嚴重的事故幾乎都源自於許多錯誤的疊加，少犯一個錯誤，結果就會完全不同。他以發生在 2025 年 6 月 12 日，Google Cloud 因程式碼錯誤導致癱瘓，進而引發全球網路服務大面積癱瘓的事件為例，稱其為計算機行業的最嚴重事故之一。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_19.jpg" /></p><h2>錯誤一：開發階段</h2><p>問題的根源在於 Google Cloud 中一個名為 <strong>Service Control</strong> 的系統。這個系統負責處理諸如身分驗證、黑白名單、限額、限流等常見檢查。2025 年 5 月 29 日，開發團隊升級了 Service Control 的限額策略功能。這段新增的程式碼忘記做一件很基礎的事情：<strong>錯誤處理</strong>。如果有人寫入一個新的策略，而這個策略恰好包含一個 <strong>空值</strong>，這段新程式碼就會引發 <strong>Null Pointer Exception</strong>，導致整個 Service Control 系統崩潰。這是開發階段出現的第一個小錯誤。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_87.jpg" /></p><h2>錯誤二：測試與部署準備</h2><p>作者提到，許多工程師在工作中會遇到功能容易寫但難測試的情況，特別是當功能會對系統造成全域性影響時。在多人共用的測試環境（staging）中，為了測試自己的功能而影響到其他人的日常工作是件麻煩的事。因此，有些工程師會為了省事而冒險，跳過 staging 環境的測試，只在本地跑幾個單元測試就認為過關了。根據調查報告，Google Cloud 中有 76 個產品的 API 都會經過 Service Control 系統。新的限額功能如果在 staging 上測試，很可能影響其他 76 個開發團隊的工作。Service Control 團隊選擇了繞過 staging 測試，導致這個沒有被發現的 <strong>Null Pointer Exception</strong> 悄悄地進入了生產環境。這是測試階段出現的第二個小錯誤。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_151.jpg" /></p><h2>錯誤三：部署策略</h2><p>到了 2025 年 6 月 12 日上午，在一次日常作業中，Google Cloud 某個分區儲存 Service Control 策略的資料庫裡被寫進了一條新的策略，這條策略裡恰好有一個指標是空的。雖然 Google 沒有公布具體是哪個分區或策略，但重要的是，這條新策略並沒有只拖垮這一個分區。作者解釋了軟體發布中常見的穩健策略，例如 <strong>金絲雀發布 (Canary release)</strong>、<strong>藍綠部署 (Blue/Green deployment)</strong>、基於地理位置或用戶分區的分階段發布。然而，Service Control 系統使用的卻是 <strong>分散式資料庫</strong> 進行策略的 <strong>同步</strong> 發布，因為他們認為提供最即時的同步服務比保證系統安全更重要。當那條有空值的策略被寫入其中一個分區的資料庫時，全球 42 個分區都同時、同步地複製了同一條策略。因此，所有的分區同時出現了 <strong>Null Pointer Exception</strong>，導致全球性癱瘓。這是部署階段出現的第三個小錯誤。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_240.jpg" /></p><h2>錯誤四：營運與復原</h2><p>相比開發團隊，Google 的營運團隊（SRE）顯然專業不少。他們在 10 分鐘內發現了問題根源，又花了 10 多分鐘寫好補丁，再花 10 多分鐘發布到所有分區，整個過程不到 40 分鐘。然而，故事並未結束。作者介紹了錯誤重試機制：早期的系統會讓錯誤任務自動重試，但在 70 年代發現這可能導致 <strong>死循環</strong>，於是發明了 <strong>指數退避 (Exponential Backoff)</strong> 機制，並在 80 年代的 Ethernet 協議中應用。這種機制能快速重試同時防止死循環。然而，當許多服務同時出錯並在同一時間進行指數退避重試時，仍然會導致資源被擠爆。因此，業界後來發展出了增加隨機性的 <strong>隨機化指數退避 (Randomized Exponential Backoff)</strong> 機制，這成為了主流做法。Google 的 Service Control 系統卻沒有使用隨機化。當系統恢復後，大量積壓的任務同時重試，又把系統衝垮了，連帶著整個分區也重新癱瘓。這是營運階段出現的第四個也是最後一個小錯誤。營運團隊被迫手動對任務進行限流，並分流到其他分區，花了將近三個小時才處理完這些積壓任務。最終統計，Google Cloud 全球 42 個分區、76 個產品總計癱瘓了 6 小時 41 分鐘，嚴重違反了他們的 SLA 承諾。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_387.jpg" /></p><h2>引發連鎖反應與產業反思</h2><p>如果只是 Google Cloud 癱瘓可能只會引發嘲笑，但這次事故透過連鎖反應引發了 <strong>Cloudflare</strong> 的癱瘓，讓整個行業開始懷疑自己。Cloudflare 作為世界上最大的網路服務商之一，基礎設施服務竟然依賴於 Google Cloud 這個平台服務來部署其核心產品 <strong>Workers KV</strong>（一個高性能鍵值儲存服務），而且是「只」依賴，沒有在其他地方做冗餘部署。這是一種嚴重的結構性失誤，也背叛了用戶對其獨立、安全、穩定的信任。Google Cloud 癱瘓導致其上的 Workers KV 癱瘓，進而導致 Cloudflare 本身癱瘓，最終引發更多平台服務和網路應用的癱瘓，造成「<strong>半個互聯網一起癱瘓</strong>」的詭異一幕。作者將此次事件與航空業的事故類比，指出兩者都是由一連串的小錯誤累積而成。然而，航空業對待事故調查報告和改進措施極為嚴肅，每一個細節、每一個要求都可能源於血的教訓，並被嚴格落實到全球的日常運作中。反觀計算機行業，對可能出現的問題從來沒有過嚴肅、嚴謹的應對態度，即使是頂尖大廠，在最重要的系統上也經常出現教科書級別的入門級錯誤。作者認為，這更多地體現出一個團隊、一個組織甚至一個行業的 <strong>紀律性缺失</strong>，依然停留在上個世紀那種缺乏社會責任感的「小眾 geek 心態」。他覺得計算機行業應該學習其他行業的態度，承受犯錯可能帶來的嚴重後果，或許這樣才能真正地做到「<strong>讓程式設計再次偉大</strong>」。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_24.jpg" /></p><hr />

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=eF0SFyCGWlg">https://www.youtube.com/watch?v=eF0SFyCGWlg</a></p><p>00:00 开场</p><p>00:19 第一个错误</p><p>01:27 第二个错误</p><p>02:31 第三个错误</p><p>04:00 第四个错误</p><p>06:27 倒反天罡</p><p>08:24 年轻人的第一次坠机</p>]]>
      </itunes:summary>
      <description>
        <![CDATA[<hr style="clear:both" />

<p><img src="https://img.youtube.com/vi/eF0SFyCGWlg/maxresdefault.jpg" /></p><h1>值得閱讀的理由</h1><ul><li>了解 Google Cloud 在 2025 年 6 月 12 日癱瘓的技術原因，以及一系列看似微小、但在各個階段累積的錯誤如何引發全球性災難。</li><li>探討軟體產業在開發、測試、部署及營運流程中常見的問題，特別是缺乏嚴謹的態度和對潛在風險的意識。</li><li>比較軟體產業與航空業在處理錯誤和追求安全上的差異，反思前者應如何借鏡其他高度監管產業的紀律性與責任感。</li></ul><hr /><h1>摘要</h1><p>作者指出，歷史上最嚴重的事故幾乎都源自於許多錯誤的疊加，少犯一個錯誤，結果就會完全不同。他以發生在 2025 年 6 月 12 日，Google Cloud 因程式碼錯誤導致癱瘓，進而引發全球網路服務大面積癱瘓的事件為例，稱其為計算機行業的最嚴重事故之一。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_19.jpg" /></p><h2>錯誤一：開發階段</h2><p>問題的根源在於 Google Cloud 中一個名為 <strong>Service Control</strong> 的系統。這個系統負責處理諸如身分驗證、黑白名單、限額、限流等常見檢查。2025 年 5 月 29 日，開發團隊升級了 Service Control 的限額策略功能。這段新增的程式碼忘記做一件很基礎的事情：<strong>錯誤處理</strong>。如果有人寫入一個新的策略，而這個策略恰好包含一個 <strong>空值</strong>，這段新程式碼就會引發 <strong>Null Pointer Exception</strong>，導致整個 Service Control 系統崩潰。這是開發階段出現的第一個小錯誤。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_87.jpg" /></p><h2>錯誤二：測試與部署準備</h2><p>作者提到，許多工程師在工作中會遇到功能容易寫但難測試的情況，特別是當功能會對系統造成全域性影響時。在多人共用的測試環境（staging）中，為了測試自己的功能而影響到其他人的日常工作是件麻煩的事。因此，有些工程師會為了省事而冒險，跳過 staging 環境的測試，只在本地跑幾個單元測試就認為過關了。根據調查報告，Google Cloud 中有 76 個產品的 API 都會經過 Service Control 系統。新的限額功能如果在 staging 上測試，很可能影響其他 76 個開發團隊的工作。Service Control 團隊選擇了繞過 staging 測試，導致這個沒有被發現的 <strong>Null Pointer Exception</strong> 悄悄地進入了生產環境。這是測試階段出現的第二個小錯誤。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_151.jpg" /></p><h2>錯誤三：部署策略</h2><p>到了 2025 年 6 月 12 日上午，在一次日常作業中，Google Cloud 某個分區儲存 Service Control 策略的資料庫裡被寫進了一條新的策略，這條策略裡恰好有一個指標是空的。雖然 Google 沒有公布具體是哪個分區或策略，但重要的是，這條新策略並沒有只拖垮這一個分區。作者解釋了軟體發布中常見的穩健策略，例如 <strong>金絲雀發布 (Canary release)</strong>、<strong>藍綠部署 (Blue/Green deployment)</strong>、基於地理位置或用戶分區的分階段發布。然而，Service Control 系統使用的卻是 <strong>分散式資料庫</strong> 進行策略的 <strong>同步</strong> 發布，因為他們認為提供最即時的同步服務比保證系統安全更重要。當那條有空值的策略被寫入其中一個分區的資料庫時，全球 42 個分區都同時、同步地複製了同一條策略。因此，所有的分區同時出現了 <strong>Null Pointer Exception</strong>，導致全球性癱瘓。這是部署階段出現的第三個小錯誤。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_240.jpg" /></p><h2>錯誤四：營運與復原</h2><p>相比開發團隊，Google 的營運團隊（SRE）顯然專業不少。他們在 10 分鐘內發現了問題根源，又花了 10 多分鐘寫好補丁，再花 10 多分鐘發布到所有分區，整個過程不到 40 分鐘。然而，故事並未結束。作者介紹了錯誤重試機制：早期的系統會讓錯誤任務自動重試，但在 70 年代發現這可能導致 <strong>死循環</strong>，於是發明了 <strong>指數退避 (Exponential Backoff)</strong> 機制，並在 80 年代的 Ethernet 協議中應用。這種機制能快速重試同時防止死循環。然而，當許多服務同時出錯並在同一時間進行指數退避重試時，仍然會導致資源被擠爆。因此，業界後來發展出了增加隨機性的 <strong>隨機化指數退避 (Randomized Exponential Backoff)</strong> 機制，這成為了主流做法。Google 的 Service Control 系統卻沒有使用隨機化。當系統恢復後，大量積壓的任務同時重試，又把系統衝垮了，連帶著整個分區也重新癱瘓。這是營運階段出現的第四個也是最後一個小錯誤。營運團隊被迫手動對任務進行限流，並分流到其他分區，花了將近三個小時才處理完這些積壓任務。最終統計，Google Cloud 全球 42 個分區、76 個產品總計癱瘓了 6 小時 41 分鐘，嚴重違反了他們的 SLA 承諾。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_387.jpg" /></p><h2>引發連鎖反應與產業反思</h2><p>如果只是 Google Cloud 癱瘓可能只會引發嘲笑，但這次事故透過連鎖反應引發了 <strong>Cloudflare</strong> 的癱瘓，讓整個行業開始懷疑自己。Cloudflare 作為世界上最大的網路服務商之一，基礎設施服務竟然依賴於 Google Cloud 這個平台服務來部署其核心產品 <strong>Workers KV</strong>（一個高性能鍵值儲存服務），而且是「只」依賴，沒有在其他地方做冗餘部署。這是一種嚴重的結構性失誤，也背叛了用戶對其獨立、安全、穩定的信任。Google Cloud 癱瘓導致其上的 Workers KV 癱瘓，進而導致 Cloudflare 本身癱瘓，最終引發更多平台服務和網路應用的癱瘓，造成「<strong>半個互聯網一起癱瘓</strong>」的詭異一幕。作者將此次事件與航空業的事故類比，指出兩者都是由一連串的小錯誤累積而成。然而，航空業對待事故調查報告和改進措施極為嚴肅，每一個細節、每一個要求都可能源於血的教訓，並被嚴格落實到全球的日常運作中。反觀計算機行業，對可能出現的問題從來沒有過嚴肅、嚴謹的應對態度，即使是頂尖大廠，在最重要的系統上也經常出現教科書級別的入門級錯誤。作者認為，這更多地體現出一個團隊、一個組織甚至一個行業的 <strong>紀律性缺失</strong>，依然停留在上個世紀那種缺乏社會責任感的「小眾 geek 心態」。他覺得計算機行業應該學習其他行業的態度，承受犯錯可能帶來的嚴重後果，或許這樣才能真正地做到「<strong>讓程式設計再次偉大</strong>」。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_24.jpg" /></p><hr />

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=eF0SFyCGWlg">https://www.youtube.com/watch?v=eF0SFyCGWlg</a></p><p>00:00 开场</p><p>00:19 第一个错误</p><p>01:27 第二个错误</p><p>02:31 第三个错误</p><p>04:00 第四个错误</p><p>06:27 倒反天罡</p><p>08:24 年轻人的第一次坠机</p>]]>
      </description>
      <content:encoded><![CDATA[<hr style="clear:both" />

<p><img src="https://img.youtube.com/vi/eF0SFyCGWlg/maxresdefault.jpg" /></p><h1>值得閱讀的理由</h1><ul><li>了解 Google Cloud 在 2025 年 6 月 12 日癱瘓的技術原因，以及一系列看似微小、但在各個階段累積的錯誤如何引發全球性災難。</li><li>探討軟體產業在開發、測試、部署及營運流程中常見的問題，特別是缺乏嚴謹的態度和對潛在風險的意識。</li><li>比較軟體產業與航空業在處理錯誤和追求安全上的差異，反思前者應如何借鏡其他高度監管產業的紀律性與責任感。</li></ul><hr /><h1>摘要</h1><p>作者指出，歷史上最嚴重的事故幾乎都源自於許多錯誤的疊加，少犯一個錯誤，結果就會完全不同。他以發生在 2025 年 6 月 12 日，Google Cloud 因程式碼錯誤導致癱瘓，進而引發全球網路服務大面積癱瘓的事件為例，稱其為計算機行業的最嚴重事故之一。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_19.jpg" /></p><h2>錯誤一：開發階段</h2><p>問題的根源在於 Google Cloud 中一個名為 <strong>Service Control</strong> 的系統。這個系統負責處理諸如身分驗證、黑白名單、限額、限流等常見檢查。2025 年 5 月 29 日，開發團隊升級了 Service Control 的限額策略功能。這段新增的程式碼忘記做一件很基礎的事情：<strong>錯誤處理</strong>。如果有人寫入一個新的策略，而這個策略恰好包含一個 <strong>空值</strong>，這段新程式碼就會引發 <strong>Null Pointer Exception</strong>，導致整個 Service Control 系統崩潰。這是開發階段出現的第一個小錯誤。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_87.jpg" /></p><h2>錯誤二：測試與部署準備</h2><p>作者提到，許多工程師在工作中會遇到功能容易寫但難測試的情況，特別是當功能會對系統造成全域性影響時。在多人共用的測試環境（staging）中，為了測試自己的功能而影響到其他人的日常工作是件麻煩的事。因此，有些工程師會為了省事而冒險，跳過 staging 環境的測試，只在本地跑幾個單元測試就認為過關了。根據調查報告，Google Cloud 中有 76 個產品的 API 都會經過 Service Control 系統。新的限額功能如果在 staging 上測試，很可能影響其他 76 個開發團隊的工作。Service Control 團隊選擇了繞過 staging 測試，導致這個沒有被發現的 <strong>Null Pointer Exception</strong> 悄悄地進入了生產環境。這是測試階段出現的第二個小錯誤。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_151.jpg" /></p><h2>錯誤三：部署策略</h2><p>到了 2025 年 6 月 12 日上午，在一次日常作業中，Google Cloud 某個分區儲存 Service Control 策略的資料庫裡被寫進了一條新的策略，這條策略裡恰好有一個指標是空的。雖然 Google 沒有公布具體是哪個分區或策略，但重要的是，這條新策略並沒有只拖垮這一個分區。作者解釋了軟體發布中常見的穩健策略，例如 <strong>金絲雀發布 (Canary release)</strong>、<strong>藍綠部署 (Blue/Green deployment)</strong>、基於地理位置或用戶分區的分階段發布。然而，Service Control 系統使用的卻是 <strong>分散式資料庫</strong> 進行策略的 <strong>同步</strong> 發布，因為他們認為提供最即時的同步服務比保證系統安全更重要。當那條有空值的策略被寫入其中一個分區的資料庫時，全球 42 個分區都同時、同步地複製了同一條策略。因此，所有的分區同時出現了 <strong>Null Pointer Exception</strong>，導致全球性癱瘓。這是部署階段出現的第三個小錯誤。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_240.jpg" /></p><h2>錯誤四：營運與復原</h2><p>相比開發團隊，Google 的營運團隊（SRE）顯然專業不少。他們在 10 分鐘內發現了問題根源，又花了 10 多分鐘寫好補丁，再花 10 多分鐘發布到所有分區，整個過程不到 40 分鐘。然而，故事並未結束。作者介紹了錯誤重試機制：早期的系統會讓錯誤任務自動重試，但在 70 年代發現這可能導致 <strong>死循環</strong>，於是發明了 <strong>指數退避 (Exponential Backoff)</strong> 機制，並在 80 年代的 Ethernet 協議中應用。這種機制能快速重試同時防止死循環。然而，當許多服務同時出錯並在同一時間進行指數退避重試時，仍然會導致資源被擠爆。因此，業界後來發展出了增加隨機性的 <strong>隨機化指數退避 (Randomized Exponential Backoff)</strong> 機制，這成為了主流做法。Google 的 Service Control 系統卻沒有使用隨機化。當系統恢復後，大量積壓的任務同時重試，又把系統衝垮了，連帶著整個分區也重新癱瘓。這是營運階段出現的第四個也是最後一個小錯誤。營運團隊被迫手動對任務進行限流，並分流到其他分區，花了將近三個小時才處理完這些積壓任務。最終統計，Google Cloud 全球 42 個分區、76 個產品總計癱瘓了 6 小時 41 分鐘，嚴重違反了他們的 SLA 承諾。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_387.jpg" /></p><h2>引發連鎖反應與產業反思</h2><p>如果只是 Google Cloud 癱瘓可能只會引發嘲笑，但這次事故透過連鎖反應引發了 <strong>Cloudflare</strong> 的癱瘓，讓整個行業開始懷疑自己。Cloudflare 作為世界上最大的網路服務商之一，基礎設施服務竟然依賴於 Google Cloud 這個平台服務來部署其核心產品 <strong>Workers KV</strong>（一個高性能鍵值儲存服務），而且是「只」依賴，沒有在其他地方做冗餘部署。這是一種嚴重的結構性失誤，也背叛了用戶對其獨立、安全、穩定的信任。Google Cloud 癱瘓導致其上的 Workers KV 癱瘓，進而導致 Cloudflare 本身癱瘓，最終引發更多平台服務和網路應用的癱瘓，造成「<strong>半個互聯網一起癱瘓</strong>」的詭異一幕。作者將此次事件與航空業的事故類比，指出兩者都是由一連串的小錯誤累積而成。然而，航空業對待事故調查報告和改進措施極為嚴肅，每一個細節、每一個要求都可能源於血的教訓，並被嚴格落實到全球的日常運作中。反觀計算機行業，對可能出現的問題從來沒有過嚴肅、嚴謹的應對態度，即使是頂尖大廠，在最重要的系統上也經常出現教科書級別的入門級錯誤。作者認為，這更多地體現出一個團隊、一個組織甚至一個行業的 <strong>紀律性缺失</strong>，依然停留在上個世紀那種缺乏社會責任感的「小眾 geek 心態」。他覺得計算機行業應該學習其他行業的態度，承受犯錯可能帶來的嚴重後果，或許這樣才能真正地做到「<strong>讓程式設計再次偉大</strong>」。</p><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/eF0SFyCGWlg_24.jpg" /></p><hr />

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=eF0SFyCGWlg">https://www.youtube.com/watch?v=eF0SFyCGWlg</a></p><p>00:00 开场</p><p>00:19 第一个错误</p><p>01:27 第二个错误</p><p>02:31 第三个错误</p><p>04:00 第四个错误</p><p>06:27 倒反天罡</p><p>08:24 年轻人的第一次坠机</p>]]></content:encoded>
      <itunes:image href="https://i.ytimg.com/vi/eF0SFyCGWlg/hqdefault.jpg"/>
      <pubDate>2025-06-17T01:50:45.000Z</pubDate>
    </item><item>
      <title><![CDATA[用正确的姿势，读懂软件工程圣经【让阅读再次伟大#1】]]></title>
      <link>https://www.youtube.com/watch?v=MsCndz66Syw</link>
      <itunes:title><![CDATA[用正确的姿势，读懂软件工程圣经【让阅读再次伟大#1】]]></itunes:title>
      <itunes:author><![CDATA[原子能]]></itunes:author>
      <itunes:summary>
        <![CDATA[<hr style="clear:both" />

<p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=48" target="_blank"><strong># 人月神话的时代背景</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_48.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=188" target="_blank"><strong># 这是历史书，不是工具书</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_188.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=299" target="_blank"><strong># 每个章节都有意义</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_299.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=371" target="_blank"><strong># 中文翻译点评</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_371.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=450" target="_blank"><strong># 尾声</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_450.jpg" /></p></p>

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=MsCndz66Syw">https://www.youtube.com/watch?v=MsCndz66Syw</a></p><p>00:00 开场</p><p>00:48 人月神话的时代背景</p><p>03:08 这是历史书，不是工具书</p><p>04:59 每个章节都有意义</p><p>06:11 中文翻译点评</p><p>07:30 尾声</p>]]>
      </itunes:summary>
      <description>
        <![CDATA[<hr style="clear:both" />

<p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=48" target="_blank"><strong># 人月神话的时代背景</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_48.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=188" target="_blank"><strong># 这是历史书，不是工具书</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_188.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=299" target="_blank"><strong># 每个章节都有意义</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_299.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=371" target="_blank"><strong># 中文翻译点评</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_371.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=450" target="_blank"><strong># 尾声</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_450.jpg" /></p></p>

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=MsCndz66Syw">https://www.youtube.com/watch?v=MsCndz66Syw</a></p><p>00:00 开场</p><p>00:48 人月神话的时代背景</p><p>03:08 这是历史书，不是工具书</p><p>04:59 每个章节都有意义</p><p>06:11 中文翻译点评</p><p>07:30 尾声</p>]]>
      </description>
      <content:encoded><![CDATA[<hr style="clear:both" />

<p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=48" target="_blank"><strong># 人月神话的时代背景</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_48.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=188" target="_blank"><strong># 这是历史书，不是工具书</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_188.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=299" target="_blank"><strong># 每个章节都有意义</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_299.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=371" target="_blank"><strong># 中文翻译点评</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_371.jpg" /></p></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><a href="https://youtu.be/MsCndz66Syw&t=450" target="_blank"><strong># 尾声</strong></a></p><p style="max-width: calc(100vw - 1rem);  word-wrap: break-word; overflow-wrap: break-word; "><p><img src="https://democwise2016.github.io/action-RSS-UT-Weekly-202506/file-cache/MsCndz66Syw_450.jpg" /></p></p>

<hr style="clear:both" />
=============
<p><a href="https://www.youtube.com/watch?v=MsCndz66Syw">https://www.youtube.com/watch?v=MsCndz66Syw</a></p><p>00:00 开场</p><p>00:48 人月神话的时代背景</p><p>03:08 这是历史书，不是工具书</p><p>04:59 每个章节都有意义</p><p>06:11 中文翻译点评</p><p>07:30 尾声</p>]]></content:encoded>
      <itunes:image href="https://i.ytimg.com/vi/MsCndz66Syw/hqdefault.jpg"/>
      <pubDate>2025-06-06T10:00:39.000Z</pubDate>
    </item></channel>
</rss>